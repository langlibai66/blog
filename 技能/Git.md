# Git

## git命令

## 获取git仓库

#### git init

将当前目录转换为Git仓库

> 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。

#### git clone

当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。

```
$ git clone 克隆仓库指令 （指定名称）
```



## 文件状态

![image](https://user-images.githubusercontent.com/62437804/166645345-fa590f8a-9259-47b3-b5b3-048996014521.png)

工作目录里的文件无非就是两种状态：已跟踪与未跟踪状态，已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已放入暂存区。简而言之，已跟踪的文件就是 Git 已经知道的文件。

当我们初次克隆某仓库的时候，仓库中的所有文件都是已跟踪文件未修改状态，仓库中的文件一旦发生修改，状态将更改为已修改，在工作时，我们可以将已修改文件放入暂存区，状态更改为暂存，然后我们可以一次性提交所有已经暂存的修改。上图就是文件的生命周期图。

#### git status

查看文件状态，状态信息中包含所在的分支以及当前所在分支与远程仓库中对应的分支是否存在偏离	

如果文件发生了改变，则在下面则会出现Untracked files的列表，提醒我们没有追踪的文件

#### git add

使用命令 git add 开始跟踪一个文件。

> 只要在 Changes to be committed 这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件在你运行 git add 时的版本将被留存在后续的历史记录中。 你可能会想起之前我们使用 git init 后就运行了 git add 命令，开始跟踪当前目录下的文件。 git add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。

git add是一个多功能的命令，可以使用他对已修改文件进行暂存

如若在暂存后再次修改了该文件，则该文件会同时出现在暂存与未暂存区域，这时我们直接提交提交的是第一次暂存的版本，如若要使用当前的版本需要再次add后再提交

**将这个命令理解为“精确地将内容添加到下一次提交中”**

#### git ignore

> 一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式。

```
范例：

# 忽略所有的 .a 文件
*.a

# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件
!lib.a

# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO
/TODO

# 忽略任何目录下名为 build 的文件夹
build/

# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt
doc/*.txt

# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件
doc/**/*.pdf
```

#### git diff 

此命令比较的是工作目录中当前文件和暂存区域快照之间的差异。 也就是修改之后还没有暂存起来的变化内容。

若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff --staged 命令。 这条命令将比对已暂存文件与最后一次提交的文件差异

**请注意，git diff 本身只显示尚未暂存的改动**

#### git commit

提交命令，执行后会启动你选择的文本编辑器来输入提交说明。

*Note 启动的编辑器是通过 Shell 的环境变量 EDITOR 指定的，一般为 vim 或 emacs。 当然也可以按照 起步 介绍的方式， 使用 git config --global core.editor 命令设置你喜欢的编辑器。*

默认的提交消息包含最后一次运行 git status 的输出，放在注释行里，另外开头还有一个空行，供你输入提交说明。 你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。

**另外，你也可以在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行**

提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（463dc4f），以及在本次提交中，有多少文件修订过，多少行添加和删改过。

每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。

**git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤**

#### git rm

git rm --cached README可以将指定文件从暂存区中移除，但是不会从本地删除，如果本地删除只需要直接 git rm-f即可，这是一种安全特性，用于防止误删尚未添加到快照的数据，这样的数据不能被 Git 恢复。

#### git mv

git mv 被改文件名 文件名

相当于执行三句\$ mv README.md README \$ git rm README.md \$ git add README 如此分开操作，Git 也会意识到这是一次重命名，所以不管何种方式结果都一样。 两者唯一的区别在于，git mv 是一条命令而非三条命令，直接使用 git mv 方便得多。 不过在使用其他工具重命名文件时，记得在提交前 git rm 删除旧文件名，再 git add 添加新文件名。

#### git log 

查看提交历史

git log 有许多选项可以帮助你搜寻你所要找的提交， 下面我们会介绍几个最常用的选项。

其中一个比较有用的选项是 -p 或 --patch ，它会显示每次提交所引入的差异（按 补丁 的格式输出）。 你也可以限制显示的日志条目数量，例如使用 -2 选项来只显示最近的两次提交，该选项除了显示基本信息之外，还附带了每次提交的变化。 当进行代码审查，或者快速浏览某个搭档的提交所带来的变化的时候，这个参数就非常有用了。 你也可以为 git log 附带一系列的总结性选项。 比如你想看到每次提交的简略统计信息，可以使用 --stat 选项，另一个非常有用的选项是 --pretty=。 这个选项可以使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如 oneline 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 short，full 和 fuller 选项，它们展示信息的格式基本一致，但是详尽程度不一。

当 oneline 或 format 与另一个 log 选项 --graph 结合使用时尤其有用。 这个选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史：

```
$ git log --pretty=format:"%h %s" --graph
* 2d3acf9 ignore errors from SIGCHLD on trap
*  5e3ee11 Merge branch 'master' of git://github.com/dustin/grit
|\
| * 420eac9 Added a method for getting the current branch.
* | 30e367c timeout code and tests
* | 5a09431 add timeout protection to grit
* | e1193f8 support for heads with slashes in them
|/
* d6016bc require time for xmlschema
*  11d191e Merge branch 'defunkt' into local
```

###### 总结

```
Table 2. git log 的常用选项
选项	说明
-p

按补丁格式显示每个提交引入的差异。

--stat

显示每次提交的文件修改统计信息。

--shortstat

只显示 --stat 中最后的行数修改添加移除统计。

--name-only

仅在提交信息后显示已修改的文件清单。

--name-status

显示新增、修改、删除的文件清单。

--abbrev-commit

仅显示 SHA-1 校验和所有 40 个字符中的前几个字符。

--relative-date

使用较短的相对时间而不是完整格式显示日期（比如“2 weeks ago”）。

--graph

在日志旁以 ASCII 图形显示分支与合并历史。

--pretty

使用其他格式显示历史提交信息。可用的选项包括 oneline、short、full、fuller 和 format（用来定义自己的格式）。

--oneline

--pretty=oneline --abbrev-commit 合用的简写。
```

## 撤销操作

#### git commit --amend

这个命令可能用在我们提交信息错误或者有文件忘记提交时进行使用

我们使用这个命令就可以再次进行提交，此时我们这次提交会将上次提交的基础上再次进行提交并且将修改信息加到本次提交上，也就是将提交补全，补全后之前提交将不再存在

#### git reset xxx

git reset命令可以取消对某文件的暂存

#### git checkout

撤销修改，将文件退回为之前的样子

请务必记得 git checkout -- 是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。

在 Git 中任何 已提交 的东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 --amend 选项覆盖的提交也可以恢复 （阅读 数据恢复 了解数据恢复）。 然而，任何你未提交的东西丢失后很可能再也找不到了。

## 远程操作

#### git remote add

运行 git remote add 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写

`git remote add jx xxxxxxxx`

#### git fetch

这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看

#### git push

git push 分支 服务器

将本地分支内容推送到上游，当你的本地版本并不是最新时，这条命令将不起作用

#### git remote rename

改远程仓库名

#### git remote remove

删除远程仓库

